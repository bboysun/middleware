## 中间件相关的学习

在这里，我们即将学习kafka, zookeeper, redis, thread等相关的知识。

#### 多线程并发

今天，我们首先学习一下多线程并发的问题，简单的模拟一个多个线程假死的场景。我们需要了解到只有当多个线程任务共同争抢同一个资源的时候就产生死锁的现象，或者假死的现象。

栗子中，生产火箭和消费火箭，我们期望的是不停的循环生产完消费，消费完再生产的结果，但是在我们的栗子中，会发现执行的某一时刻就就hang死不会动了，这是为什么呢？

仔细想想，是因为我们每次notify()的时候，有可能会唤醒同一种类型的类（生产者唤醒生产者，消费者唤醒消费者），假死现象就是全部线程都进入了WAITING状态，此时程序不再执行任何功能。

当发生了这样的问题时，我们可以通过jstack + pid来查看是否有假死的现象发生。那我们怎么解决这个问题呢？

我们要用notifyAll()的方法去唤醒所有的等待线程去执行相关任务，这样避免了只唤醒同类型的对象类。

#### redis缓存

今天封装了redis的API接口，使用jedisPool获取redis客户端后需要注意的是每次执行完操作后需要调用close()方法关闭客户端，不然会造成并发情况卡死的现象。

目前提供了分布式锁，通过postman并发请求测试了分布式锁的可用性，同时使用ResponseEntity改进了restful请求。

在修改gitignore后，忽略了redis的配置文件上传到github，但是因为缓存的原因并不会直接生效。需要先git rm -r --cached . 然后再git add .

#### zookeeper

今天封装了zookeeper的API接口，使用curator组件进行的封装接口，主要做了对一个节点的增删改的操作，当然后续还可以根据自己的想要添加更多的功能。

目前提供了一种 NodeCache 的监听器，针对一个节点的增删改做响应的监听机制，可以通过 NodeCacheListener 监听器自定义相应的业务操作。当然还有两种其他的监听，

* NodeCache: 对一个节点进行监听，监听事件包括指定的路径节点的增、删、改的操作。

* PathChildrenCache: 对指定的路径节点的一级子目录进行监听，不对该节点的操作进行监听，对其子目录的节点进行增、删、改的操作监听

* TreeCache:  可以将指定的路径节点作为根节点（祖先节点），对其所有的子节点操作进行监听，呈现树形目录的监听，可以设置监听深度，最大监听深度为2147483647（int类型的最大值）。

都是类似的操作，想要的了解的可以自行封装操作，另外还有比如事务的处理，分布式锁的处理，curator都有很快捷的API供我们快速使用。比如分布式锁是通过有序临时节点实现的，等等。